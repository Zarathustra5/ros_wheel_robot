#!/usr/bin/env python3
import rospy, math
from geometry_msgs.msg import Twist
from sensor_msgs.msg import Range, LaserScan

MYROBOT_MAX_LIN_VEL = 0.6
MYROBOT_MAX_ANG_VEL = 2
MYROBOT_SPEED = 1
SEGMENTS = 24

def lerp(a, b, coeff):
    return float(a) + float(b-a) * float(coeff)

class KeyboardTeleop:    
    def __init__(self):
        rospy.init_node('keyboard_teleop')

        self.pub = rospy.Publisher('/controller/cmd_vel', Twist, queue_size=10)
        self.sub_front_0 = rospy.Subscriber('/my_robot/sensor/left', Range, self.onIRSensor0)
        self.dist_front_0 = 0.0
        self.sub_front_1 = rospy.Subscriber('/my_robot/sensor/center', Range, self.onIRSensor1)
        self.dist_front_1 = 0.0
        self.sub_front_2 = rospy.Subscriber('/my_robot/sensor/right', Range, self.onIRSensor2)
        self.dist_front_2 = 0.0

        self.sub_lidar = rospy.Subscriber('/my_robot/rplidar/scan', LaserScan, self.onLaserSensor)
        self.distances = []

        for i in range(SEGMENTS):
            self.distances.append(0)


        self.target_linear_vel   = 0.0
        self.target_angular_vel  = 0.0
        
    def run(self):
        rate = rospy.Rate(10)
        try:
            while not rospy.is_shutdown():
                self.update_velocity()
                rate.sleep()
        except rospy.ROSInterruptException:
            pass 

    def onIRSensor0(self, msg):
        self.dist_front_0 = msg.range / msg.max_range
    def onIRSensor1(self, msg):
        self.dist_front_1 = msg.range / msg.max_range
    def onIRSensor2(self, msg):
        self.dist_front_2 = msg.range / msg.max_range
    def onLaserSensor(self, msg):
        for i in range(SEGMENTS):
            self.distances[i] = 9999

        angle = msg.angle_min
        for r in msg.ranges:
            if math.isinf(r):
                r = 12

            a = angle * 180 / math.pi
            idx = int(a / (360 / SEGMENTS)) % SEGMENTS
            # print(repr(idx) + ' of ' + repr(a) + ' with dist= ' + repr(r))
            self.distances[idx] = min(self.distances[idx], r)
            angle = angle + msg.angle_increment

    def update_velocity(self):
        # print('distances: ' + repr(self.distances))

        #self.target_linear_vel = 0
        #self.target_angular_vel = 0

        if self.dist_front_1 < 0.8:
            print('case 1: ' + repr(self.dist_front_1))
            self.target_angular_vel = MYROBOT_MAX_ANG_VEL
        elif self.dist_front_0 < 0.8:
            print('case 2: ' + repr(self.dist_front_0))
            self.target_linear_vel = MYROBOT_MAX_LIN_VEL * self.dist_front_0
            self.target_angular_vel = MYROBOT_MAX_ANG_VEL * (1 - self.dist_front_0)
        elif self.dist_front_2 < 0.8:
            print('case 3: ' + repr(self.dist_front_2))
            self.target_linear_vel = MYROBOT_MAX_LIN_VEL * self.dist_front_2
            self.target_angular_vel = -MYROBOT_MAX_ANG_VEL * (1 - self.dist_front_2)
        else:
            best_idx = 12
            best_val = self.distances[best_idx]
            for i in range(8, 16):
                if self.distances[i] > best_val:
                    best_val = self.distances[i]
                    best_idx = i
            coeff = float(best_idx - 6) / 12.0
            self.target_angular_vel = lerp(-float(MYROBOT_MAX_ANG_VEL), float(MYROBOT_MAX_ANG_VEL), coeff)
            print('best_val=' + repr(best_val) + ' best_idx=' + repr(best_idx) + ' coeff=' + repr(coeff) + ' vel=' + repr(self.target_angular_vel))
            self.target_linear_vel = MYROBOT_MAX_LIN_VEL * (1.0 - abs(coeff - 0.5) * 2.0)


        twist = Twist()
        twist.linear.x = self.target_linear_vel; twist.linear.y = 0.0; twist.linear.z = 0.0
        twist.angular.x = 0.0; twist.angular.y = 0.0; twist.angular.z = self.target_angular_vel
        self.pub.publish(twist)

if __name__=="__main__":
    teleop = KeyboardTeleop()
    teleop.run()
